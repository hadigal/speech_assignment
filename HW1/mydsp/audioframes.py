"""
Name: audioframes.py
Author: Hrishikesh Adigal
Red ID: 819708988
"""

# python imports
import math
import numpy as np
import scipy.io.wavfile as spw

class AudioFrames:
    """AudioFrames
    A class for iterating over frames of audio data
    """
    
    def __init__(self, filename, adv_ms, len_ms):
        """"AudioFrames(filename, adv_ms, len_ms)
        Create a stream of audio frames where each is in len_ms milliseconds long
        and frames are advanced by adv_ms.              
        """
        # file params
        self.filename = filename
        self.adv_ms = adv_ms
        self.len_ms = len_ms
        self.count = 0 # iterator var
        self.sp_rate, self.ch_data = spw.read(self.filename) # getting sample rate and data
        self.total_data = int(self.ch_data.shape[0])
        # self.total_data = len(self.ch_data)
        self.len_n = int(self.sp_rate*(len_ms/1000)) # getting frames from sample using the frame len
        self.adv_n = int(self.sp_rate*(adv_ms/1000)) #getting frames from sample using the adv frame len
        # file param dictionary
        self.param_dict = {filename:
            {"adv_ms" : self.adv_ms,"len_ms":self.len_ms,"len_n":self.len_n,"adv_n":self.adv_n}}

    def get_framelen_samples(self):
        "get_framelen_samples - Return frame length in samples"
        return self.sp_rate*self.len_ms/1000
    
    def get_framelen_ms(self):
        "get_framelen_ms - Return frame length in ms"
        return self.len_ms
    
    def get_frameadv_samples(self):
        "get_frameadv_ms - Return frame advance in samples"
        return self.sp_rate*self.adv_ms/1000

    def get_frameadv_ms(self):
        "get_frameadv_ms - Return frame advance in ms"
        return self.adv_ms
    
    def get_Fs(self):
        "get_Fs() - Return sample rate"
        return self.sp_rate
    
    def __len__(self):
        "len() - number of frames"
        # return len(self.frames)
        return math.ceil(self.total_data/self.adv_n)

    def get_Nyquist(self):
        """get_Nyquist - Return Nyquist rate (highest frequency that can
        be represented with the sample rate. 
        """
        return self.sp_rate/2
        
    def get_params(self):
        """Return dictionary with file parameters
            fields:
                filename - name of sound file
                Fs - sample rate
                framing - nested dictionary with fields:
                    adv_ms - frame advance in ms
                    len_ms - frame length in ms
                    adv_N, len_N - frame advance & length in samples
        """
        return self.param_dict
    
    def shape(self):
        """shape() - shape of tensor generated by iterator
        Returns a numpy array containing the dimensions of each frame.
        
        This will be useful later on.  Tensors are generalizations of
        vectors and matrices (see Wolfram MathWorld for a concise definition)
        and generally can be thought of as arbitrary-dimensioned matrices.
        """
        
        # You can create a numpy array from list l with np.asarray(l)
        return [self.len_n,1]
    
    def size(self):
        """size() - Returns a Numpy array of size 1 with the number of elements 
        in the tensor associated with each frame 
        """
        
        # You can create a numpy array from list l iwth np.asarray(l)
        return self.len_n*1

    def __iter__(self):
        """"iter() - Return a frame iterator
        (Multiple iterators on same soundfile are not guaranteed to work as expected)
        """
        # Implementation decision
        # You can return self and implement a __next__(self) in this class
        # or you can create and return an instance of an iteration class
        # of your design that supports __next__(self).
        return self

    def __next__(self):
        """
        Implemented the __next__() for the iterator method
        returning the frame
        """
        if self.count >= len(self.ch_data):
            raise StopIteration
        else:
            self.count += self.adv_n
            startidx = self.count - self.adv_n
            return self.get_data(startidx,self.len_n)
    
    def seek_sample(self, N):
        "seek_sample(N) - Next iterator will start with sample N"
        self.count = N-1
    
    def get_data(self, startidx, N):
        """get_data(startidx, N) - Retrieve N samples starting at startidx.
        This has no side effects, the file position of iterators is unchanged.
        Raises a ValueError if outside range of signal.
        """
        if (startidx >= self.total_data) or (startidx < 0):
            raise ValueError
        else:
            return self.ch_data[startidx:startidx+N]
